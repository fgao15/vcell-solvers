/* Steven Andrews, started 10/22/2001.
 This is the header for the functions in the Smoldyn program.  See documentation
 called Smoldyn_doc1.pdf and Smoldyn_doc2.pdf.
 Copyright 2003-2011 by Steven Andrews.  This work is distributed under the terms
 of the Gnu General Public License (GPL). */

#ifndef __smoldynfuncs_h__
#define __smoldynfuncs_h__

//#include <time.h>
//#include <stdio.h>
//#include "opengl2.h"
#include "smoldyn.h"
#include "parse.h"
#include "SimCommand.h"
//#include "smoldyn_config.h"			// generated by the ./configure script

#ifdef VCELL_HYBRID
#include <VCELL/CartesianMesh.h>
#include <VCELL/Element.h>
#include <Expression.h>
using VCell::Expression;
#include <SimpleSymbolTable.h>
#endif


/*********************** Global variable declarations **********************/

extern void (*LoggingCallback)(simptr,int,const char*);
extern int ThrowThreshold;
extern FILE* LogFile;


void printfException(const char* format, ...);
//#ifdef LOGGING
//	extern void (*loggingCallback)(int severity, char* errMessage);
//	#define CHECK(A) if(!(A)) {if(loggingCallback){loggingCallback(2,"Unable to allocate memory");} goto failure;} else (void)0
//	#define CHECKBUG(A,B) if(!(A)) {if(loggingCallback){loggingCallback(2,B);} goto failure;} else (void)0
//	#define CHECKS(A,B) if(!(A)) {if(loggingCallback){loggingCallback(2,B);} strncpy(erstr,B,STRCHAR-1); erstr[STRCHAR-1]='\0'; goto failure;} else (void)0
//#else
	#define CHECK(A) if(!(A)) {printfException("Unable to allocate memory."); goto failure;} else (void)0
	#define CHECKBUG(A,B) if(!(A)) {printfException("%s",B); goto failure;} else (void)0
	#define CHECKS(A,B) if(!(A)) {strncpy(erstr,B,STRCHAR-1); erstr[STRCHAR-1]='\0'; goto failure;} else (void)0
//#endif


/********************************* Molecules *******************************/

// enumerated type functions
enum MolecState molstring2ms(char *string);
char *molms2string(enum MolecState ms,char *string);
enum MolListType molstring2mlt(char *string);
char *molmlt2string(enum MolListType mlt,char *string);

// low level utilities
int molwildcardname(molssptr mols,char *name,int channel,int itest);
int readmolname(simptr sim,char *str,enum MolecState *msptr,int channel);
char *molpos2string(simptr sim,moleculeptr mptr,char *string);
void molchangeident(simptr sim,moleculeptr mptr,int ll,int m,int i,enum MolecState ms,panelptr pnl);
int molssetgausstable(simptr sim,int size);
void molsetdifc(simptr sim,int ident,enum MolecState ms,double difc);
int molsetdifm(simptr sim,int ident,enum MolecState ms,double *difm);
int molsetdrift(simptr sim,int ident,enum MolecState ms,double *drift);
void molsetdisplaysize(simptr sim,int ident,enum MolecState ms,double dsize);
void molsetcolor(simptr sim,int ident,enum MolecState ms,double *color);
void molsetlistlookup(simptr sim,int ident,enum MolecState ms,int ll);
void molsetexist(simptr sim,int ident,enum MolecState ms,int exist);
int molcount(simptr sim,int i,enum MolecState ms,boxptr bptr,int max);
double MolCalcDifcSum(simptr sim,int i1,enum MolecState ms1,int i2,enum MolecState ms2);

// memory management
moleculeptr molalloc(int dim);
void molfree(moleculeptr mptr);
molssptr molssalloc(molssptr mols,int maxspecies);
int mollistalloc(molssptr mols,int maxlist,enum MolListType mlt);
int molexpandlist(molssptr mols,int dim,int ll,int nspaces,int nmolecs);
void molssfree(molssptr mols);

// data structure output
void molssoutput(simptr sim);
void writemols(simptr sim,FILE *fptr);
void writemolecules(simptr sim,FILE *fptr);
int checkmolparams(simptr sim,int *warnptr);

// structure setup
int molenablemols(simptr sim,int maxspecies);
void molsetcondition(molssptr mols,enum StructCond cond,int upgrade);
int addmollist(simptr sim,const char *nm,enum MolListType mlt);
int molsetmaxspecies(simptr sim,int max);
int molsetmaxmol(simptr sim,int max);
int moladdspecies(simptr sim,const char *nm);
int molsetexpansionflag(simptr sim,int i,int flag);
int molsupdateparams(molssptr mols,double dt);
int molsupdatelists(simptr sim);
int molsupdate(simptr sim);

// adding and removing molecules
void molkill(simptr sim,moleculeptr mptr,int ll,int m);
moleculeptr getnextmol(molssptr mols);
moleculeptr newestmol(molssptr mols);
int addmol(simptr sim,int nmol,int ident,double *poslo,double *poshi,int sort);
int addsurfmol(simptr sim,int nmol,int ident,enum MolecState ms,double *pos,panelptr pnl,int surface,enum PanelShape ps,char *pname);
int addcompartmol(simptr sim,int nmol,int ident,compartptr cmpt);
int molgetexport(simptr sim,int ident,enum MolecState ms);
int molputimport(simptr sim,int nmol,int ident,enum MolecState ms,panelptr pnl,enum PanelFace face);
int moldummyporter(simptr sim);

// core simulation functions
int molsort(simptr sim);
int diffuse(simptr sim);
int diffuse_threaded(simptr sim);  // diffuses all molecules -- multithreaded ?????? change

/*********************************** Walls **********************************/

// low level utilities
void systemrandpos(simptr sim,double *pos);
double systemvolume(simptr sim);
void systemcorners(simptr sim,double *poslo,double *poshi);
double systemdiagonal(simptr sim);
int posinsystem(simptr sim,double *pos);
double wallcalcdist2(simptr sim,double *pos1,double *pos2,int wpcode,double *vect);

// memory management
wallptr wallalloc(void);
void wallfree(wallptr wptr);
wallptr *wallsalloc(int dim);
void wallsfree(wallptr *wlist,int dim);

// data structure output
void walloutput(simptr sim);
void writewalls(simptr sim,FILE *fptr);
int checkwallparams(simptr sim,int *warnptr);

// structure setup
int walladd(simptr sim,int d,int highside,double pos,char type);
int wallsettype(simptr sim,int d,int highside,char type);

// core simulation functions
int checkwalls_threaded(simptr sim,int ll,int reborn,boxptr bptr);//?? change
int checkwalls(simptr sim,int ll,int reborn,boxptr bptr);//?? change

/********************************* Reactions ********************************/

// enumerated types
enum RevParam rxnstring2rp(char *string);
char *rxnrp2string(enum RevParam rp,char *string);

// low level utilities
int readrxnname(simptr sim,char *rname,int *orderptr,rxnptr *rxnpt);
int rxnpackident(int order,int maxspecies,int *ident);
void rxnunpackident(int order,int maxspecies,int ipack,int *ident);
enum MolecState rxnpackstate(int order,enum MolecState *mstate);
void rxnunpackstate(int order,enum MolecState mspack,enum MolecState *mstate);
int rxnreactantstate(rxnptr rxn,enum MolecState *mstate,int convertb2f);
int rxnallstates(rxnptr rxn);
int findreverserxn(simptr sim,int order,int r,int *optr,int *rptr);
int rxnisprod(simptr sim,int i,enum MolecState ms,int code);

// memory management
rxnptr rxnalloc(int order);
void rxnfree(rxnptr rxn);
rxnssptr rxnssalloc(rxnssptr rxnss,int order,int maxspecies);
void rxnssfree(rxnssptr rxnss);
int rxnexpandmaxspecies(simptr sim,int maxspecies);

// data structure output
void rxnoutput(simptr sim,int order);
void writereactions(simptr sim,FILE *fptr);
int checkrxnparams(simptr sim,int *warnptr);

// parameter calculations
int rxnsetrate(simptr sim,int order,int r,char *erstr);
int rxnsetrates(simptr sim,int order,char *erstr);
int rxnsetproduct(simptr sim,int order,int r,char *erstr);
int rxnsetproducts(simptr sim,int order,char *erstr);
double rxncalcrate(simptr sim,int order,int r,double *pgemptr);
void rxncalctau(simptr sim,int order);

// structure set up
void rxnsetcondition(simptr sim,int order,enum StructCond cond,int upgrade);
int RxnSetValue(simptr sim,char *option,rxnptr rxn,double value);
int RxnSetRevparam(simptr sim,rxnptr rxn,enum RevParam rparamt,double rparam,int prd,double *pos,int dim);
void RxnSetPermit(simptr sim,rxnptr rxn,int order,enum MolecState *rctstate,int value);
void RxnSetCmpt(rxnptr rxn,compartptr cmpt);
void RxnSetSurface(rxnptr rxn,surfaceptr srf);
rxnptr RxnAddReaction(simptr sim,const char *rname,int order,int *rctident,enum MolecState *rctstate,int nprod,int *prdident,enum MolecState *prdstate,compartptr cmpt,surfaceptr srf);
rxnptr RxnAddReactionCheck(simptr sim,char *rname,int order,int *rctident,enum MolecState *rctstate,int nprod,int *prdident,enum MolecState *prdstate,compartptr cmpt,surfaceptr srf,char *erstr);
int loadrxn(simptr sim,ParseFilePtr *pfpptr,char *line2,char *erstr);
int rxnsupdateparams(simptr sim);
int rxnsupdatelists(simptr sim,int order);
int rxnsupdate(simptr sim);

// core simulation functions
int doreact(simptr sim,rxnptr rxn,moleculeptr mptr1,moleculeptr mptr2,int ll1,int m1,int ll2,int m2,double *pos,panelptr pnl);
int zeroreact(simptr sim);
int unireact(simptr sim);
int unireact_threaded(simptr sim);//??????? change
int morebireact(simptr sim,rxnptr rxn,moleculeptr mptr1,moleculeptr mptr2,int ll1,int m1,int ll2,enum EventType et,double *vect);
int bireact(simptr sim,int neigh);
int bireact_threaded(simptr sim,int neigh);//???? change
int bireact_threaded_intrabox(simptr sim);//????? change
int bireact_threaded_interbox(simptr sim);//????? change

void* check_for_intrabox_bireactions_threaded(void* data);//????? change

/********************************* Surfaces *********************************/

// enumerated types
enum PanelFace surfstring2face(char *string);
char *surfface2string(enum PanelFace face,char *string);
enum SrfAction surfstring2act(char *string);
char *surfact2string(enum SrfAction act,char *string);
enum PanelShape surfstring2ps(char *string);
char *surfps2string(enum PanelShape ps,char *string);
enum DrawMode surfstring2dm(char *string);
char *surfdm2string(enum DrawMode dm,char *string);

// low level utilities
int readsurfacename(simptr sim,char *str,enum PanelShape *psptr,int *pptr);
int panelpoints(enum PanelShape ps,int dim);
int surfpanelparams(enum PanelShape ps,int dim);
void panelmiddle(panelptr pnl,double *middle,int dim,int onpanel);
double panelarea(panelptr pnl,int dim);
double surfacearea(surfaceptr srf,int dim,int *totpanelptr);
double surfacearea2(simptr sim,int surface,enum PanelShape ps,char *pname,int *totpanelptr);
void panelrandpos(panelptr pnl,double *pos,int dim);
panelptr surfrandpos(surfaceptr srf,double *pos,int dim);
int issurfprod(simptr sim,int i,enum MolecState ms);
int srfsamestate(enum MolecState ms1,enum PanelFace face1,enum MolecState ms2,enum MolecState *ms3ptr);
void srfreverseaction(enum MolecState ms1,enum PanelFace face1,enum MolecState ms2,enum MolecState *ms3ptr,enum PanelFace *face2ptr,enum MolecState *ms4ptr);
void srftristate2index(enum MolecState ms,enum MolecState ms1,enum MolecState ms2,enum MolecState *ms3ptr,enum PanelFace *faceptr,enum MolecState *ms4ptr);
void srfindex2tristate(enum MolecState ms3,enum PanelFace face,enum MolecState ms4,enum MolecState *msptr,enum MolecState *ms1ptr,enum MolecState *ms2ptr);

// memory management
surfactionptr surfaceactionalloc(int species);
void surfaceactionfree(surfactionptr actdetails);
int panelsalloc(surfaceptr srf,int dim,int maxpanel,int maxspecies,enum PanelShape ps);
void panelfree(panelptr pnl);
int emittersalloc(surfaceptr srf,enum PanelFace face,int oldmaxspecies,int maxspecies);
surfaceptr surfacealloc(surfaceptr srf,int oldmaxspecies,int maxspecies,int dim);
void surfacefree(surfaceptr srf,int maxspecies);
surfacessptr surfacessalloc(surfacessptr srfss,int maxsurface,int maxspecies,int dim);
void surfacessfree(surfacessptr srfss);

// data structure output
void surfaceoutput(simptr sim);
void writesurfaces(simptr sim,FILE *fptr);
int checksurfaceparams(simptr sim,int *warnptr);

// structure set up
int surfenablesurfaces(simptr sim,int maxsurf);
int surfexpandmaxspecies(simptr sim,int maxspecies);
surfaceptr surfaddsurface(simptr sim,const char *surfname);
void surfsetcondition(surfacessptr surfss,enum StructCond cond,int upgrade);
int surfsetepsilon(simptr sim,double epsilon);
int surfsetmargin(simptr sim,double margin);
int surfsetneighdist(simptr sim,double neighdist);
int surfsetcolor(surfaceptr srf,enum PanelFace face,double *rgba);
int surfsetedgepts(surfaceptr srf,double value);
int surfsetstipple(surfaceptr srf,int factor,int pattern);
int surfsetdrawmode(surfaceptr srf,enum PanelFace face,enum DrawMode dm);
int surfsetshiny(surfaceptr srf,enum PanelFace face,double shiny);
int surfsetaction(surfaceptr srf,int i,enum MolecState ms,enum PanelFace face,enum SrfAction act);
int surfsetrate(surfaceptr srf,int ident,enum MolecState ms,enum MolecState ms1,enum MolecState ms2,int newident,double value,int which);
int surfsetmaxpanel(surfaceptr srf,int dim,enum PanelShape ps,int maxpanel);
int surfaddpanel(surfaceptr srf,int dim,enum PanelShape ps,const char *string,double *params,const char *name);
int surfsetemitterabsorption(simptr sim);
int surfsetjumppanel(surfaceptr srf,panelptr pnl1,enum PanelFace face1,int bidirect,panelptr pnl2,enum PanelFace face2);
double srfcalcrate(simptr sim,surfaceptr srf,int i,enum MolecState ms1,enum PanelFace face,enum MolecState ms2);
double srfcalcprob(simptr sim,surfaceptr srf,int i,enum MolecState ms1,enum PanelFace face,enum MolecState ms2);
int surfsetneighbors(panelptr pnl,panelptr *neighlist,int nneigh,int add);
int surfaddemitter(surfaceptr srf,enum PanelFace face,int i,double amount,double *pos,int dim);
surfaceptr surfreadstring(simptr sim,surfaceptr srf,char *word,char *line2,char *erstr);
int loadsurface(simptr sim,ParseFilePtr *pfpptr,char *line2,char *erstr);
int surfupdateparams(simptr sim);
int surfupdatelists(simptr sim);
int surfupdate(simptr sim);

// core simulation functions
enum PanelFace panelside(double* pt,panelptr pnl,int dim,double *distptr);
void panelnormal(panelptr pnl,double *pos,enum PanelFace face,int dim,double *norm);
int lineXpanel(double *pt1,double *pt2,panelptr pnl,int dim,double *crsspt,enum PanelFace *face1ptr,enum PanelFace *face2ptr,double *crossptr,double *cross2ptr,int *veryclose);
int ptinpanel(double *pt,panelptr pnl,int dim);
enum SrfAction surfaction(surfaceptr srf,enum PanelFace face,int ident,enum MolecState ms,int *i2ptr,enum MolecState *ms2ptr);
int rxnXsurface(simptr sim,moleculeptr mptr1,moleculeptr mptr2);
void fixpt2panel(double *pt,panelptr pnl,int dim,enum PanelFace face,double epsilon);
void movept2panel(double *pt,panelptr pnl,int dim,double margin);
double closestpanelpt(panelptr pnl,int dim,double *testpt,double *pnlpt);
double closestsurfacept(surfaceptr srf,int dim,double *testpt,double *pnlpt,panelptr *pnlptr);
void movemol2closepanel(simptr sim,moleculeptr mptr,int dim,double epsilon,double neighdist,double margin);
void surfacereflect(moleculeptr mptr,panelptr pnl,double *crsspt,int dim,enum PanelFace face);
int surfacejump(moleculeptr mptr,panelptr pnl,double *crsspt,enum PanelFace face,int dim);
int dosurfinteract(simptr sim,moleculeptr mptr,int ll,int m,panelptr pnl,enum PanelFace face,double *crsspt);
int checksurfaces(simptr sim,int ll,int reborn);
int checksurfacebound(simptr sim,int ll);

int checksurfaces_threaded(simptr sim,int ll,int reborn);

/*********************************** Boxes **********************************/

// low level utilities
void box2pos(simptr sim,boxptr bptr,double *poslo,double *poshi);
boxptr pos2box(simptr sim,double *pos);
void boxrandpos(simptr sim,double *pos,boxptr bptr);
int panelinbox(simptr sim,panelptr pnl,boxptr bptr);
int boxaddmol(moleculeptr mptr,int ll);
void boxremovemol(moleculeptr mptr,int ll);

// memory management
boxptr boxalloc(int dim,int nlist);
int expandbox(boxptr bptr,int n,int ll);
int expandboxpanels(boxptr bptr,int n);
void boxfree(boxptr bptr,int nlist);
boxptr *boxesalloc(int nbox,int dim,int nlist);
void boxesfree(boxptr *blist,int nbox,int nlist);
boxssptr boxssalloc(int dim);
void boxssfree(boxssptr boxs);

// data structure output
void boxoutput(boxssptr boxs,int blo,int bhi,int dim);
void boxssoutput(simptr sim);
int checkboxparams(simptr sim,int *warnptr);

// structure set up
void boxsetcondition(boxssptr boxs,enum StructCond cond,int upgrade);
int boxsetsize(simptr sim,char *info,double val);
int boxesupdateparams(simptr sim);
int boxesupdatelists(simptr sim);
int boxesupdate(simptr sim);

// core simulation functions
boxptr line2nextbox(simptr sim,double *pt1,double *pt2,boxptr bptr);
int reassignmolecs(simptr sim,int diffusing,int reborn);

/******************************* Compartments *******************************/

// enumerated types
enum CmptLogic compartstring2cl(char *string);
char *compartcl2string(enum CmptLogic cls,char *string);

// low level utilities
int posincompart(simptr sim,double *pos,compartptr cmpt);
int compartrandpos(simptr sim,double *pos,compartptr cmpt);
int loadHighResVolumeSamples(simptr sim,ParseFilePtr *pfpptr,char *line2,char *erstr);

// memory management
compartptr compartalloc(void);
void compartfree(compartptr cmpt);
compartssptr compartssalloc(compartssptr cmptss,int maxcmpt);
void compartssfree(compartssptr cmptss);

// data structure output
void compartoutput(simptr sim);
void writecomparts(simptr sim,FILE *fptr);
int checkcompartparams(simptr sim,int *warnptr);

// structure set up
void compartsetcondition(compartssptr cmptss,enum StructCond cond,int upgrade);
int compartenablecomparts(simptr sim,int maxcmpt);
compartptr compartaddcompart(simptr sim,const char *cmptname);
int compartaddsurf(compartptr cmpt,surfaceptr srf);
int compartaddpoint(compartptr cmpt,int dim,double *point);
int compartaddcmptl(compartptr cmpt,compartptr cmptl,enum CmptLogic sym);
int compartupdatebox(simptr sim,compartptr cmpt,boxptr bptr,double volfrac);
compartptr compartreadstring(simptr sim,compartptr cmpt,char *word,char *line2,char *erstr);
int loadcompart(simptr sim,ParseFilePtr *pfpptr,char *line2,char *erstr);
int compartsupdateparams(simptr sim);
int compartsupdatelists(simptr sim);
int compartsupdate(simptr sim);

/*********************************** Ports **********************************/

// memory management
portptr portalloc(void);
void portfree(portptr port);
portssptr portssalloc(portssptr portss,int maxport);
void portssfree(portssptr portss);

// data structure output
void portoutput(simptr sim);
void writeports(simptr sim,FILE *fptr);
int checkportparams(simptr sim,int *warnptr);

// structure set up
void portsetcondition(portssptr portss,enum StructCond cond,int upgrade);
int portenableports(simptr sim,int maxport);
portptr portaddport(simptr sim,const char *portname,surfaceptr srf,enum PanelFace face);
portptr portreadstring(simptr sim,portptr port,char *word,char *line2,char *erstr);
int loadport(simptr sim,ParseFilePtr *pfpptr,char* line2,char *erstr);
int portsupdateparams(simptr sim);
int portsupdatelists(simptr sim);
int portsupdate(simptr sim);

// core simulation functions
int portgetmols(simptr sim,portptr port,int ident,enum MolecState ms,int remove);
int portputmols(simptr sim,portptr port,int nmol,int ident,int *species,double **positions);
int porttransport(simptr sim1,portptr port1,simptr sim2,portptr port2);

/******************************** Moleculizer *******************************/

// low level utilities
int mzrReadStreamName(char *str,char *streamname,enum MolecState *msptr);
int mzrGetSpeciesStreams(mzrssptr mzrss,char ***streamnames,int *numnames);
void mzrFreeSpeciesStreams(char **streamnames,int numnames);
int mzrIsSmolNameInStream(mzrssptr mzrss,char *smolname,char *stream);

// memory management
void mzrssfree(mzrssptr mzrss);

// data structure output
int mzrCheckParams(simptr sim,int *warnptr);
int mzrNumberOfSpecies(mzrssptr mzrss);
int mzrNumberOfReactions(mzrssptr mzrss);
void mzrssoutput(simptr sim);
void mzrsswrite(simptr sim,FILE *fptr);

// structure set up
int mzrSetDefaultState(simptr sim,int ident,enum MolecState ms);
int mzrSetStreamDisplay(mzrssptr mzrss,char *streamname,enum MolecState ms,double displaysize,double *color);
int mzrSetStreamDifc(mzrssptr mzrss,char *streamname,enum MolecState ms,double difc);
int mzrssreadrules(simptr sim,ParseFilePtr *pfpptr,char *erstr);
void mzrSetValue(mzrssptr mzrss,char *item,int i1);
int mzrsetupmoleculizer(simptr sim,char *erstr);

// core simulation functions
int mzrExpandSpecies(simptr sim,int ident);

/******************************** Threading *********************************/
//???????????? all of this section is new, and undocumented
int getnumberofthreads(simptr sim);
void setnumberofthreads(simptr sim, int newNumber);
void clearthreaddata( threadptr pthread);
stack* alloc_stack(); // Creates a new stack
void free_stack(stack* pStack); // Frees the stack
void push_data_onto_stack(stack* pStack, void* data, size_t data_size);
void clear_stack(stack* pStack);
threadssptr alloc_threadss(int number);
int calculatestride(int total_number, int number_threads);

/********************************* Graphics *********************************/

// enumerated types
enum LightParam graphicsstring2lp(char *string);
char *graphicslp2string(enum LightParam lp,char *string);

// low level utilities
int graphicsreadcolor(char **stringptr,double *rgba);

// memory management
graphicsssptr graphssalloc(void);
void graphssfree(graphicsssptr graphss);

// data structure output
void graphssoutput(simptr sim);
void writegraphss(simptr sim,FILE *fptr);
int checkgraphicsparams(simptr sim,int *warnptr);

// structure setup
void graphicssetcondition(graphicsssptr graphss,enum StructCond cond,int upgrade);
int graphicsenablegraphics(simptr sim,char *type);
int graphicssetiter(simptr sim,int iter);
int graphicssettiffiter(simptr sim,int iter);
int graphicssetdelay(simptr sim,int delay);
int graphicssetframethickness(simptr sim,double thickness);
int graphicssetframecolor(simptr sim,double *color);
int graphicssetgridthickness(simptr sim,double thickness);
int graphicssetgridcolor(simptr sim,double *color);
int graphicssetbackcolor(simptr sim,double *color);
int graphicssettextcolor(simptr sim,double *color);
int graphicssettextitem(simptr sim,char *itemname);
int graphicssetlight(simptr sim,graphicsssptr graphss,int lt,enum LightParam ltparam,double *value);

// structure update functions
int graphicsupdateinit(simptr sim);
int graphicsupdatelists(simptr sim);
int graphicsupdateparams(simptr sim);
int graphicsupdate(simptr sim);

// core simulation functions
void RenderSurfaces(simptr sim);
void RenderMolecs(simptr sim);
void RenderText(simptr sim);
void RenderSim(simptr sim);

// top level OpenGL functions
void smolsimulategl(simptr sim);

/********************************* Commands *********************************/

enum CMDcode docommand(void *cmdfnarg,cmdptr cmd,char *line);
void cmdmeansqrdispfree(cmdptr cmd);

/******************************** Simulation ********************************/

// global variable management
void simSetLogging(FILE *logfile,void (*logFunction)(simptr,int,const char*, ...));
void simSetThrowing(int corethreshold);

// enumerated types
enum SmolStruct simstring2ss(char *string);
char *simss2string(enum SmolStruct ss,char *string);
char *simsc2string(enum StructCond sc,char *string);

// low level utilities
double simversionnumber(void);
void Simsetrandseed(simptr sim,long int randseed);

// memory management
simptr simalloc(const char *root);
void simfree(simptr sim);
void simfuncfree(void);

// data structure output
void simLog(simptr sim,int importance,const char* format, ...);
void simoutput(simptr sim);
void simsystemoutput(simptr sim);
void writesim(simptr sim,FILE *fptr);
void checksimparams(simptr sim);

// structure set up
int simsetpthreads(simptr sim,int number);
void simsetcondition(simptr sim,enum StructCond cond,int upgrade);
void simsetrunmode(simptr sim,int runmode);
int simsetdim(simptr sim,int dim);
int simsettime(simptr sim,double time,int code);
int simreadstring(simptr sim,const char *word,char *line2,char *erstr);
int loadsim(simptr sim,const char *fileroot,const char *filename,char *erstr,const char *flags);
int simupdate(simptr sim,char *erstr);
int setupsim(const char *root,const char *filename,simptr *smptr,const char *flags);

// core simulation functions
int simdocommands(simptr sim);
int simulatetimestep(simptr sim);
void endsimulate(simptr sim,int er);
int smolsimulate(simptr sim);

/********************************* Threads **********************************/
//???????????? all of this section is new, and undocumented
void threadssfree(threadssptr threads);

void* checksurfaces_threaded_helper(void* data);
void* check_for_reactions_threaded(void* data);

int checksurfaces(simptr sim,int ll,int reborn);

typedef struct surface_data_struct {
	simptr sim;
	int live_list_ndx;
	int firstNdx;
	int secondNdx;
	int resurrect_only;
	} *ptrsurfacefuncdata;

/********************************* Hybrid **********************************/
#ifdef VCELL_HYBRID
namespace VCell {
	class Expression;
}
class CartesianMesh;
double evaluateRnxRate(rxnptr reaction, simptr sim, int volIndex);
double evaluateRnxRate2(simptr sim, Expression* rateExp, bool isMemRnx, double* pos, char* panelName);
int randomPosInMesh(CartesianMesh* mesh, simptr sim, double* pos, int volIndex);
#endif

#endif

